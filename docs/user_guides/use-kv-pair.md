# How to use key/value pairs

## Basics

To save a key/value pair to a bucket, use the `tx.Put`:

```go
if err := db.Update(
    func(tx *nutsdb.Tx) error {
    key := []byte("name1")
    val := []byte("val1")
    bucket := "bucket1"
    if err := tx.Put(bucket, key, val, 0); err != nil {
        return err
    }
    return nil
}); err != nil {
    log.Fatal(err)
}
```

This will set the value of the "name1" key to "val1" in the bucket1 bucket.

To update the the value of the "name1" key,we can still use the `tx.Put`:

```go
if err := db.Update(
    func(tx *nutsdb.Tx) error {
    key := []byte("name1")
    val := []byte("val1-modify") // Update the value
    bucket := "bucket1"
    if err := tx.Put(bucket, key, val, 0); err != nil {
        return err
    }
    return nil
}); err != nil {
    log.Fatal(err)
}
```

To retrieve this value, we can use the `tx.Get`:

```go
if err := db.View(
func(tx *nutsdb.Tx) error {
    key := []byte("name1")
    bucket := "bucket1"
    if value, err := tx.Get(bucket, key); err != nil {
        return err
    } else {
        fmt.Println(string(value)) // "val1-modify"
    }
    return nil
}); err != nil {
    log.Println(err)
}
```

To retrieve the value and set the new value, we can use the `Tx.GetSet`:
```go
err := db.Update(
    func(tx *nutsdb.Tx) error {
        bucket := "bucket1"
        key := []byte("name1")
        val := []byte("val3")
        oldValue, err := tx.GetSet(bucket, key, val)
        if err != nil {
            return err
        }

        fmt.Println("old value :", string(oldValue))

        return nil
    },
); 
if err != nil {
    log.Println(err)
}
```

Use the `tx.Delete()` to delete a key from the bucket:

```go
if err := db.Update(
    func(tx *nutsdb.Tx) error {
    key := []byte("name1")
    bucket := "bucket1"
    if err := tx.Delete(bucket, key); err != nil {
        return err
    }
    return nil
}); err != nil {
    log.Fatal(err)
}
```

Use `tx.ValueLen()` to retrieve the length of the value stored by the key

```go
err := db.View(
    func(tx *nutsdb.Tx) error {
        key := []byte("name1")
        bucket := "bucket1"
        if length, err := tx.ValueLen(bucket, key); err != nil {
            return err
        } else {
            fmt.Println(length);
        }
        return nil
    },
);
if err != nil {
    log.Fatal(err)
}
```

## Bit operations

* Use `tx.GetBit()` retrieves the value of a key at a certain offset. When the corresponding key exists, it returns the value at the position corresponding to the offset in the parameter. When the offset exceeds the original data range, it returns 0 without reporting an error; When the corresponding key does not exist, an error message will appear indicating that the key does not exist.

```golang
if err := db.View(func(tx *nutsdb.Tx) error {
	bucket := "bucket"
	key := []byte("key")
	offset := 2
    bit, err := tx.GetBit(bucket, key, offset)
    if err != nil {
        return err
    }
    log.Println("get bit:", bit)
    return nil
}); err != nil {
    log.Println(err)
}
```

* Use `tx.SetBit()` method adds the value corresponding to a key at a certain offset. When the corresponding key exists, the value on the bit corresponding to the offset will be modified; When the corresponding key does not exist or the offset exceeds the original data range, the original value will be expanded until it can be modified at the position corresponding to the offset. Except for the position corresponding to the offset, the values of the bits generated by automatic expansion are all 0.

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
	bucket := "bucket"
	key := []byte("key")
	offset := 2
	bit := 1
	return tx.SetBit(bucket, key, offset, bit)
}); err != nil {
    log.Println(err)
}
```

## Increments and Decrements

The key needs to be present for increment and decrement operations on values, otherwise an error will be reported indicating that the key does not exist. When the result of incrementing and decrementing a value will be outside the range of `int64`, a string-based large number calculation will be used, so you don't have to worry about the range of the value being too large.

* Use the `tx.Incr()` method to make the value corresponding to a key increment itself by 1

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
	bucket := "bucket"
	key := []byte("key")
    return tx.Incr(bucket, key)
}); err != nil {
    log.Println(err)
}
```

* Use the `tx.IncrBy()` method to have the value corresponding to a key self-increment by the specified value

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    return tx.IncrBy(bucket, key, 10)
}); err != nil {
    log.Println(err)
}
```

* Use the `tx.Decr()` method to make the value corresponding to a key self-decrease by 1

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
	bucket := "bucket"
	key := []byte("key")
    return tx.Decr(bucket, key)
}); err != nil {
    log.Println(err)
}
```

* Use the `tx.DecrBy()` method to make the value corresponding to a key subtract itself from the specified value

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    return tx.DecrBy(bucket, key, 10)
}); err != nil {
    log.Println(err)
}
```
## PutIfNotExists and PutIfExits

* Use `PutIfNotExists` set the value for a key in bucket only if the key doesn't exist in the bucket already.

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    value := []byte("value")
    ttl := unit32(100)
    return tx.PutIfNotExists(bucket, key, value, ttl)
}); err != nil {
    log.Println(err)
}
```

* Use `PutIfExits`` set the value for a key in  bucket only if the key already exits in the bucket.

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    value := []byte("value")
    ttl := unit32(100)
    return tx.PutIfExists(bucket, key, value, ttl)
}); err != nil {
    log.Println(err)
}
```

## GetTTL and Persist 

* Use `GetTTL` to get remaining TTL of a value by key. It returns (-1, nil) if TTL is Persistent, (0, ErrBucketNotFound|ErrKeyNotFound) If expired or bucket/key not found and (remaining TTL and nil) if the record exits.

```golang
if err := db.View(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    ttl, err := tx.GetTTL(bucket, key)
    if err != nil {
        return err
    }
    log.Println(ttl)
    return nil
}); err != nil {
    log.Println(err)
}
```

* Use `Persist` to update record's TTL as Persistent if the record exits.

```golang
if err := db.Update(func(tx *nutsdb.Tx) error {
    bucket := "bucket"
    key := []byte("key")
    return tx.Persist(bucket, key, value, ttl)
}); err != nil {
    log.Println(err)
}
```